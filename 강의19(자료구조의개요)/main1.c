//#자료구조의 개요
//자료구조의 필요성
//데이터의 효과적 저장&처리에 대한 학문
//불필요하게 메모리와 성능 낭비할 여지를 막는다
//데이터를 가장 빠르게 찾도록 하는 자료구조??
//프로그래머에게 답을 제공하는 역할 
//1) 선형구조
//배열 연결리스트 스택 큐
//트리(tree) 그래프(graph)

//효율적인 자료구조 설계를 위해 알고리즘 지식 피요
//효율적 알고리즘 위해 문제상황에 맞는 적절한 자료구조가 사용돼야 함
//따라서 자료구조론과 알고리즘 이론은 모두 동일선상에 놓을 수 있음


//시간 복잡도: 알고리즘에 사용되는 연산 횟수
//공간 복잡도: 알고리즘에 사용되는 메모리의 양
//시간복잡도와 공간복잡도를 얼마나 효과적으로 써서 프로그램 만드는지가 중요한 주제
//효율적 알고리즘 사용 가정할 떼 시간과 공간은 반비례
//공간을  많이 차지할 경우 시간 빠르고, 공간 적게 차지할 경우 시간소요 많음
//필요에 따라 한 가지는 포기

//시간 복잡도를 표현할 떼 최악의 경우를 나타내는 Big-O표기법을 사용
//최악의 경우를 상정하고 가정했을 때 얼마나 소요될 것인가
//다음 알고리즘은 O(n)의 시간 복잡도를 가짐

//입력받은 b의 값만큼 i가 0부터 b까지 반복
/*
int main(void) {
	int a, b;
	cin >> a >> b;
	int sum = 1;
	for (int i = 0; i < b; i++) {
		sum *= a;
	}
	cout << sum;

}

//O(n^2)의 시간 복잡도 사용
//이중for문(반복문의 반복문 사용)=>n^2만큼 반복
//i가 0부터 n까지 반복할 때마다
//j가 0부터 i까지 반복 >> n^2만큼 반복
#include <iostream>
using namespace std;

int main(void) {
	int n;
	cin >> n;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j <= i; j++) {
			cout << "*";
		}
		cout << '\n';
	}

}

//다음 알고리즘의 시간 복잡도는?
//a랑 b를 더하는 값을 바로 출력 =>> 1
// 즉 O(1)이라고 할 수 있음
#include <iostream>

using namespace std;

int main(void) {
	int a, b;
	cin >> a >> b;
	cout << a + b;
		   }*/

//10억번 이상의 연산일 경우 1초 이상 소요
//웬만해서는 10억번 넘어가지 않도록 프로그래밍

//시간 복잡도 표기시 항상 큰 항과 계수만 표시
//n이 무한정 커진다고 가정할 때 계수는 의미 없어지므로
//현실적인 다양한 문제에서 시간제한은 1초!

//공간 복잡도 표기시 일반적으로 MB단위로 표기
// int a[1000]: 4KB
// int a[1000000]: 4MB
// int a[2000][2000]: 2차원 배열로 4백만개의 INT형(하나에 4바이트)> 총 16MB

//프로그램 작성시 자료구조를 적절히 활용하여 성능 최적화를 노려야 함