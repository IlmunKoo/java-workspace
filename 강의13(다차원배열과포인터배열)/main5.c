//#포인터 배열의 구조분석

/*
#include <stdio.h>


int main(void) {
    int a[5] = { 1, 2, 3, 4, 5 };
    //a배열에 5개의 원소 넣음
    int* p = a;  //포인터 이용 a배열의 주소값 넣음
       
    printf("%d\n", *(p++));
    //1번째 원소: 1 가리킴 & p에 1더함(p =2 )
    printf("%d\n", *(++p));
    // p에 1더하고 (p = 3) 원소 가리킴: 3
    printf("%d\n", *(p + 2));    
    //이어서 2칸 출력: 5
    system("pause");

    //=> 포인터연산&증감연산자의 출력 대학시험에서 물어봄
}*/

//#2차원 배열을 포인터로 처리(포인터를 포인터로 처리할 수있으므로)

#include <stdio.h>


int main(void) {
    int a[2][5] = { { 1, 2, 3, 4, 5 }
        , { 6, 7, 8, 9, 10 } };

     
    int(*p)[5] = a[1]; //하나의 포인터변수*p를 만듦, 원소5개가진다
    //하나에 5개의 열을 가지는 행을 의미하는 포인터 =(*p)[5]
    //두번째 열 선택: a[1]
    //두번째 행의 첫번째 원소 6을 가리키는 주소값(a[1])
     //배열을 가리키는 포인터로 만들어 줌
    //특정한 행을 가리키는 포인터>> 이중포인터
    int i;
    for (i = 0; i < 5; i++) {
     printf("%d", p[0][i]);
     //두번째행 원소 모두 출력
     //기본적으로 포인터 p가 두번째 행을 가리키므로 p[0] ={ 6, 7, 8, 9, 10 } 
    }
     
    system("pause");
}
    //=> 포인터연산&증감연산자의 출력 대학시험에서 물어봄
//2차원 배열은 이중포인터와 흡사